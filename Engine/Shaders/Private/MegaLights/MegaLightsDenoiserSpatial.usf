// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "MegaLights.ush"
#include "../Lumen/LumenReflectionDenoiserCommon.ush"

// Spatial denoise is the last pass writing to the SceneColor buffer. We allow SSS checkerboard pixel to adjust 
// DiffuseColor/SpecularColor to write specular & diffuse lighting in checkerboard pattern
#define ALLOW_SSS_MATERIAL_OVERRIDE 1

Texture2D<float4> DiffuseLightingAndSecondMomentTexture;
Texture2D<float4> SpecularLightingAndSecondMomentTexture;
Texture2D<UNORM float> NumFramesAccumulatedTexture;
RWTexture2D<float4> RWSceneColor;

float SpatialFilterDepthWeightScale;
float SpatialFilterKernelRadius;
uint SpatialFilterNumSamples;
float TemporalMaxFramesAccumulated;

/**
 * Run a spatial filter in order to filter out noise based on the temporal variance.
 */
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void DenoiserSpatialCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 ScreenCoord = DispatchThreadId.xy + View.ViewRectMinAndSize.xy;

	#if DEBUG_MODE
		int2 DebugScreenCoord = View.CursorPosition.x >= 0 ? View.CursorPosition * View.ViewResolutionFraction : -1;
		bool bDebug = all(ScreenCoord == DebugScreenCoord);
		FShaderPrintContext Context = InitShaderPrintContext(true, float2(0.55, 0.7));
	#endif

	if (all(ScreenCoord < View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw))
	{
		float2 ScreenUV = (ScreenCoord + 0.5f) * View.BufferSizeAndInvSize.zw;

		float4 CenterDiffuseLightingAndSecondMoment = DiffuseLightingAndSecondMomentTexture[ScreenCoord];
		float4 CenterSpecularLightingAndSecondMoment = SpecularLightingAndSecondMomentTexture[ScreenCoord];

		if (IsLightingValid(CenterDiffuseLightingAndSecondMoment.xyz))
		{
			FMegaLightsMaterial Material = LoadMaterial(ScreenUV, ScreenCoord);

			float CenterDiffuseStdDev = sqrt(max(CenterDiffuseLightingAndSecondMoment.w - Pow2(Luminance(CenterDiffuseLightingAndSecondMoment.xyz)), 0.0f));
			float CenterSpecularStdDev = sqrt(max(CenterSpecularLightingAndSecondMoment.w - Pow2(Luminance(CenterSpecularLightingAndSecondMoment.xyz)), 0.0f));
	
			// Run spatial filter until we accumulate enough frames to estimated temporal variance
			float NumFramesAccumulated = NumFramesAccumulatedTexture[ScreenCoord] * TemporalMaxFramesAccumulated;
			CenterDiffuseStdDev = lerp(1.0f, CenterDiffuseStdDev, saturate(NumFramesAccumulated / min(5.0f, TemporalMaxFramesAccumulated)));

			float3 DiffuseLightingSum = CenterDiffuseLightingAndSecondMoment.xyz;
			float3 SpecularLightingSum = CenterSpecularLightingAndSecondMoment.xyz;
			float DiffuseLightingWeightSum = 1.0f;
			float SpecularLightingWeightSum = 1.0f;

			uint2 RandomSeed = Rand3DPCG16(int3(ScreenCoord, MegaLightsStateFrameIndex)).xy;

			float3 TranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(ScreenUV, Material.Depth);
			float4 ScenePlane = float4(Material.WorldNormalForPositionBias, dot(TranslatedWorldPosition, Material.WorldNormalForPositionBias));

			// #ml_todo: expose as CVars
			float MinStdDev = 0.1f;

			#if SPATIAL_FILTER
			if (Material.bAllowSpatialFilter && SpatialFilterKernelRadius > 0.0f && (CenterDiffuseStdDev > MinStdDev || CenterSpecularStdDev > MinStdDev))
			{
				for (uint NeighborIndex = 0; NeighborIndex < SpatialFilterNumSamples; ++NeighborIndex)
				{
					float2 NeighborOffsetInRect = Hammersley16(NeighborIndex, SpatialFilterNumSamples, RandomSeed);
					float2 NeighborOffset = UniformSampleDiskConcentric(NeighborOffsetInRect) * SpatialFilterKernelRadius;
					int2 NeighborCoord = (int2)(ScreenCoord + NeighborOffset);

					if (all(and(NeighborCoord >= View.ViewRectMinAndSize.xy, NeighborCoord < (View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw))))
					{
						// Depth weight
						float2 NeighborScreenUV = (NeighborCoord + 0.5f) * View.BufferSizeAndInvSize.zw;
						const FMegaLightsMaterial NeighborMaterial = LoadMaterial(NeighborScreenUV, NeighborCoord);
						const float3 NeighborTranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(NeighborScreenUV, NeighborMaterial.Depth);
						float PlaneDistance = abs(dot(float4(NeighborTranslatedWorldPosition, -1), ScenePlane));
						float RelativeDepthDifference = PlaneDistance / Material.Depth;
						float DepthWeight = exp2(-SpatialFilterDepthWeightScale * (RelativeDepthDifference * RelativeDepthDifference));

						// #sdl_todo: separate weight for specular accounting for roughness and expose as CVars
						// Normal weight
						float AngleBetweenNormals = acosFast(saturate(dot(ScenePlane.xyz, NeighborMaterial.WorldNormalForPositionBias)));
						float NormalWeight = 1.0f - saturate(AngleBetweenNormals);

						// Diffuse
						if (CenterDiffuseStdDev > MinStdDev)
						{
							float4 NeighborDiffuseLightingAndSecondMoment = DiffuseLightingAndSecondMomentTexture[NeighborCoord];

							if (IsLightingValid(NeighborDiffuseLightingAndSecondMoment.xyz))
							{
								float LuminanceDelta = abs(Luminance(CenterDiffuseLightingAndSecondMoment.xyz) - Luminance(NeighborDiffuseLightingAndSecondMoment.xyz));
								float LuminanceWeight = exp2(-LuminanceDelta / max(CenterDiffuseStdDev, 0.001f));

								const float DiffuseNeighborWeight = DepthWeight * NormalWeight * LuminanceWeight;
								DiffuseLightingSum += NeighborDiffuseLightingAndSecondMoment.xyz * DiffuseNeighborWeight;
								DiffuseLightingWeightSum += DiffuseNeighborWeight;
							}
						}

						// Specular
						if (CenterSpecularStdDev > MinStdDev)
						{
							float4 NeighborSpecularLightingAndSecondMoment = SpecularLightingAndSecondMomentTexture[NeighborCoord];

							if (IsLightingValid(NeighborSpecularLightingAndSecondMoment.xyz))
							{
								float LuminanceDelta = abs(Luminance(CenterSpecularLightingAndSecondMoment.xyz) - Luminance(NeighborSpecularLightingAndSecondMoment.xyz));
								float LuminanceWeight = exp2(-LuminanceDelta / max(CenterSpecularStdDev, 0.001f));

								const float SpecularNeighborWeight = DepthWeight * NormalWeight * LuminanceWeight;
								SpecularLightingSum += NeighborSpecularLightingAndSecondMoment.xyz * SpecularNeighborWeight;
								SpecularLightingWeightSum += SpecularNeighborWeight;
							}
						}
					}
				}
			}
			#endif

			// Final pass outputs composites irradiance and outputs it to scene color
			float3 DiffuseLighting = DiffuseLightingSum / DiffuseLightingWeightSum;
			float3 SpecularLighting = SpecularLightingSum / SpecularLightingWeightSum;
			ModulateLighting(Material, TranslatedWorldPosition, DiffuseLighting, SpecularLighting);

			// Composite diffuse and specular into scene color
			FLightAccumulator LightAccumulator = (FLightAccumulator)0;
			LightAccumulator_AddSplit(LightAccumulator, DiffuseLighting, SpecularLighting, /*ScatterableLight*/ DiffuseLighting, /*CommonMultiplier*/ 1.0f, Material.bNeedsSeparateSubsurfaceLightAccumulation);
			float4 AccumulatedSceneColor = LightAccumulator_GetResult(LightAccumulator);

			#if DEBUG_MODE
			if (bDebug)
			{
				Print(Context, TEXT("Spatial pass"));
				Newline(Context);
				Print(Context, TEXT("AccumulatedSceneColor: "));
				Print(Context, AccumulatedSceneColor);
				Newline(Context);
				Print(Context, CenterSpecularLightingAndSecondMoment);
				Newline(Context);
				Print(Context, TEXT("CenterDiffuseStdDev:  "));
				Print(Context, CenterDiffuseStdDev);
				Newline(Context);
				Print(Context, TEXT("CenterSpecularStdDev: "));
				Print(Context, CenterSpecularStdDev);
			}
			#endif

			RWSceneColor[ScreenCoord] = RWSceneColor[ScreenCoord] + AccumulatedSceneColor;
		}
	}
}