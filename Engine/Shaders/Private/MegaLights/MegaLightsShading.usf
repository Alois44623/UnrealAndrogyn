// Copyright Epic Games, Inc. All Rights Reserved.

#ifndef TILE_TYPE
	#define TILE_TYPE TILE_MODE_EMPTY
#endif

#ifndef NUM_SAMPLES_PER_PIXEL_1D
	#define NUM_SAMPLES_PER_PIXEL_1D 1
	#define NUM_SAMPLES_PER_PIXEL_2D_X 1
	#define NUM_SAMPLES_PER_PIXEL_2D_Y 1
#endif

// When loading SSS checkerboard pixel, do not adjust DiffuseColor/SpecularColor to preserve specular and diffuse lighting values for each pixel
#define ALLOW_SSS_MATERIAL_OVERRIDE 0

#include "../Common.ush"
#include "../BlueNoise.ush"
#include "MegaLights.ush"
#include "../Lumen/LumenReflectionDenoiserCommon.ush"

RWTexture2D<float3> RWResolvedDiffuseLighting;
RWTexture2D<float3> RWResolvedSpecularLighting;

int2 SampleViewMin;
int2 SampleViewSize;

StructuredBuffer<uint> TileAllocator;
StructuredBuffer<uint> TileData;
uint TileDataStride;

Texture2D<uint> LightSamples;
Texture2D<float4> CompositeUpsampleWeights;

// 4x4 neighborhood with borders
#define SHARED_TILE_SIZE_X ((4 + 2) * NUM_SAMPLES_PER_PIXEL_2D_X)
#define SHARED_TILE_SIZE_Y ((4 + 2) * NUM_SAMPLES_PER_PIXEL_2D_Y)
groupshared uint SharedSamples[SHARED_TILE_SIZE_X][SHARED_TILE_SIZE_Y];

// Light scalarization
groupshared uint SharedLightHiMask;
groupshared uint SharedLightMask[SHARED_LIGHT_MASK_SIZE];

void AccumulateLightSample(uint2 SharedSampleCoord, uint LocalLightIndex, float UpsampleWeight, inout float SampleWeightSum)
{
	for (uint SampleOffsetY = 0; SampleOffsetY < NUM_SAMPLES_PER_PIXEL_2D_Y; ++SampleOffsetY)
	{
		for (uint SampleOffsetX = 0; SampleOffsetX < NUM_SAMPLES_PER_PIXEL_2D_X; ++SampleOffsetX)
		{
			FLightSample LightSample = UnpackLightSample(SharedSamples[SharedSampleCoord.x * NUM_SAMPLES_PER_PIXEL_2D_X + SampleOffsetX][SharedSampleCoord.y * NUM_SAMPLES_PER_PIXEL_2D_Y + SampleOffsetY]);

			if (LightSample.LocalLightIndex == LocalLightIndex)
			{
				SampleWeightSum += LightSample.Weight * UpsampleWeight;
			}
		}
	}
}

/**
 * Upsample light weights and apply all lights per pixel to affected tiles
 */
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ShadeLightSamplesCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint LinearThreadIndex = GroupThreadId.x + GroupThreadId.y * THREADGROUP_SIZE;

	if (LinearThreadIndex == 0)
	{
		SharedLightHiMask = 0;
	}

	if (LinearThreadIndex < SHARED_LIGHT_MASK_SIZE)
	{
		SharedLightMask[LinearThreadIndex] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	uint TileIndex = GroupId.x;
	if (TileIndex < TileAllocator[TILE_TYPE])
	{
		uint2 TileCoord = UnpackTile(TileData[TileIndex + TILE_TYPE * TileDataStride]);
		uint2 ScreenCoord = TileCoord * TILE_SIZE + GroupThreadId.xy;
		uint LocalLightHiMask = 0;

		// First load all samples into shared memory
		for (uint SharedCoordY = GroupThreadId.y; SharedCoordY < SHARED_TILE_SIZE_Y; SharedCoordY += THREADGROUP_SIZE)
		{
			for (uint SharedCoordX = GroupThreadId.x; SharedCoordX < SHARED_TILE_SIZE_X; SharedCoordX += THREADGROUP_SIZE)
			{
				const uint2 NumSamplesPerPixel = uint2(NUM_SAMPLES_PER_PIXEL_2D_X, NUM_SAMPLES_PER_PIXEL_2D_Y);
				uint2 SharedSampleCoord = uint2(SharedCoordX, SharedCoordY);
				int2 DownsampledScreenCoord = int2(TileCoord * TILE_SIZE - 1) / DOWNSAMPLE_FACTOR + SharedSampleCoord / NumSamplesPerPixel;
				int2 SampleCoord = DownsampledScreenCoord * NumSamplesPerPixel + SharedSampleCoord % NumSamplesPerPixel;

				FLightSample LightSample = InitLightSample();

				if (and(all(SampleCoord >= SampleViewMin), all(SampleCoord < SampleViewMin + SampleViewSize)))
				{
					LightSample = UnpackLightSample(LightSamples[SampleCoord]);

					if (LightSample.bVisible && LightSample.LocalLightIndex < MAX_LOCAL_LIGHT_INDEX)
					{
						uint DWORDIndex = LightSample.LocalLightIndex / 32;
						uint BitMask = 1u << (LightSample.LocalLightIndex % 32);
						InterlockedOr(SharedLightMask[DWORDIndex], BitMask);

						uint HiBitMask = 1u << DWORDIndex;
						LocalLightHiMask |= HiBitMask;
					}
					else
					{
						LightSample = InitLightSample();
					}
				}

				SharedSamples[SharedSampleCoord.x][SharedSampleCoord.y] = PackLightSample(LightSample);
			}
		}

		uint WaveHiMask = WaveActiveBitOr(LocalLightHiMask);
		if (WaveIsFirstLane())
		{
			InterlockedOr(SharedLightHiMask, WaveHiMask);
		}

		GroupMemoryBarrierWithGroupSync();

		if (all(ScreenCoord < View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw))
		{
	#if DEBUG_MODE
			int2 DebugScreenCoord = View.CursorPosition.x >= 0 ? View.CursorPosition * View.ViewResolutionFraction : -1;
			bool bDebug = all(ScreenCoord == DebugScreenCoord);
			FShaderPrintContext Context = InitShaderPrintContext(true, float2(0.55, 0.05));
	#endif

			float2 ScreenUV = (ScreenCoord + 0.5f) * View.BufferSizeAndInvSize.zw;
			FMegaLightsMaterial Material = LoadMaterial(ScreenUV, ScreenCoord, TILE_TYPE == TILE_MODE_SIMPLE_SHADING /*bForceSimpleShading*/);

			// #ml_todo: handle this path when shadows are disabled
			float ScreenSpaceAO = 1.0f;//Texture2DSampleLevel(SceneTexturesStruct.ScreenSpaceAOTexture, SceneTexturesStruct_ScreenSpaceAOTextureSampler, ScreenUV, 0).x;

			float3 DiffuseLighting = INVALID_LIGHTING;
			float3 SpecularLighting = INVALID_LIGHTING;

			if (Material.Depth > 0.0f && Material.IsValid())
			{
				DiffuseLighting = 0.0f;
				SpecularLighting = 0.0f;

				float3 TranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(ScreenUV, Material.Depth);
				float3 CameraVector = normalize(TranslatedWorldPosition - View.TranslatedWorldCameraOrigin);
				float4 DownsampledScreenWeights = CompositeUpsampleWeights[ScreenCoord];

				#if DEBUG_MODE
				if (bDebug)
				{
					Print(Context, TEXT("ShadeSamplesCS"));
					Newline(Context);
					Print(Context, TEXT("ScreenCoord: "));
					Print(Context, ScreenCoord.x);
					Print(Context, ScreenCoord.y);
					Newline(Context);

					Print(Context, TEXT("LocalLightId |LightId   | Weight    | Diffuse   | Specular"));
				}
				#endif

				uint LightHiMask = SharedLightHiMask;
				while (LightHiMask != 0)
				{
					const uint NextHiBitIndex = firstbitlow(LightHiMask);
					const uint NextHiBitMask = 1u << NextHiBitIndex;
					LightHiMask ^= NextHiBitMask;

					const uint MaskIndex = NextHiBitIndex;
					uint LightMask = SharedLightMask[MaskIndex];

					while (LightMask != 0)
					{
						const uint NextBitIndex = firstbitlow(LightMask);
						const uint NextBitMask = 1u << NextBitIndex;
						LightMask ^= NextBitMask;

						const uint LocalLightIndex = MaskIndex * 32 + NextBitIndex;

						const FLocalLightData LocalLightData = GetLocalLightDataNonStereo(LocalLightIndex);
						FDeferredLightData LightData = ConvertToDeferredLight(LocalLightData);

						uint2 SharedSampleCoord00 = (GroupThreadId.xy + 1) / DOWNSAMPLE_FACTOR;

						float SampleWeight = 0.0f;
						AccumulateLightSample(SharedSampleCoord00 + uint2(0, 0), LocalLightIndex, DownsampledScreenWeights.x, SampleWeight);
						AccumulateLightSample(SharedSampleCoord00 + uint2(1, 0), LocalLightIndex, DownsampledScreenWeights.y, SampleWeight);
						AccumulateLightSample(SharedSampleCoord00 + uint2(0, 1), LocalLightIndex, DownsampledScreenWeights.z, SampleWeight);
						AccumulateLightSample(SharedSampleCoord00 + uint2(1, 1), LocalLightIndex, DownsampledScreenWeights.w, SampleWeight);

						if (SampleWeight > 0.01f && LightData.IESAtlasIndex >= 0)
						{
							// #ml_todo: evaluate moving this to CompositeLightSamplesCS
							SampleWeight *= ComputeLightProfileMultiplier(TranslatedWorldPosition, LightData.TranslatedWorldPosition, -LightData.Direction, LightData.Tangent, LightData.IESAtlasIndex);
						}

						#if DEBUG_MODE
						if (bDebug)
						{
							Newline(Context);
							Print(Context, LocalLightIndex);
							Print(Context, LocalLightData.LightSceneId);
							Print(Context, SampleWeight);
						}
						#endif

						if (SampleWeight > 0.0f)
						{
							float4 LightAttenuation = 1.0f;
							float Dither = 0.5f;
							float SurfaceShadow = 1;
							float AmbientOcclusion = ScreenSpaceAO;
							LightData.ShadowedBits = 0;

							FDeferredLightingSplit SplitLighting = GetMegaLightsSplitLighting(
								TranslatedWorldPosition, CameraVector, Material, AmbientOcclusion, 
								LightData, LightAttenuation, Dither, ScreenCoord, 
								SurfaceShadow);

							DiffuseLighting += SplitLighting.DiffuseLighting.xyz * SampleWeight;
							SpecularLighting += SplitLighting.SpecularLighting.xyz * SampleWeight;

							#if DEBUG_MODE 
							if (bDebug)
							{
								Print(Context, SplitLighting.DiffuseLighting.xyz);
								Print(Context, SplitLighting.SpecularLighting.xyz);
							}
							#endif
						}
					}
				}

				// Apply pre-exposure
				DiffuseLighting *= View.PreExposure;
				SpecularLighting *= View.PreExposure;

				DemodulateLighting(Material, TranslatedWorldPosition, DiffuseLighting, SpecularLighting);
			}

			#if DEBUG_MODE
			if (bDebug)
			{
				Newline(Context);
				Print(Context, TEXT("Diffuse:  ")); 
				Print(Context, DiffuseLighting);
				Newline(Context);
				Print(Context, TEXT("Specular: ")); 
				Print(Context, SpecularLighting);
			}
			#endif

			RWResolvedDiffuseLighting[ScreenCoord] = DiffuseLighting;
			RWResolvedSpecularLighting[ScreenCoord] = SpecularLighting;
		}
	}
}

/**
 * Clear some data for empty tiles, which won't be processed by ShadeLightSamplesCS
 */
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ClearResolvedLightingCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint TileIndex = GroupId.x;
	if (TileIndex < TileAllocator[TILE_MODE_EMPTY])
	{
		uint2 TileCoord = UnpackTile(TileData[TileIndex + TILE_MODE_EMPTY * TileDataStride]);
		uint2 ScreenCoord = TileCoord * TILE_SIZE + GroupThreadId.xy;

		if (all(ScreenCoord < View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw))
		{
			RWResolvedDiffuseLighting[ScreenCoord] = INVALID_LIGHTING;
			RWResolvedSpecularLighting[ScreenCoord] = INVALID_LIGHTING;
		}
	}
}