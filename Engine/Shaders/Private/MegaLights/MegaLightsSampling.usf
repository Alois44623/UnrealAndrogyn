// Copyright Epic Games, Inc. All Rights Reserved.

#ifndef NUM_SAMPLES_PER_PIXEL_1D
	#define NUM_SAMPLES_PER_PIXEL_1D 1
	#define NUM_SAMPLES_PER_PIXEL_2D_X 1
	#define NUM_SAMPLES_PER_PIXEL_2D_Y 1
#endif

#ifndef TILE_TYPE
	#define TILE_TYPE TILE_MODE_EMPTY
#endif

// When loading SSS checkerboard pixel, do not adjust DiffuseColor/SpecularColor to preserve specular and diffuse lighting values for each pixel
#define ALLOW_SSS_MATERIAL_OVERRIDE 0

// Disable hair backlit during sample generation as Hair's TT term creates too much false positive: 
// the TT terms is very strong, and is in most case occluded by underlying geometry (head/body/...)
#define HAIR_BSDF_BACKLIT 0

#include "../Common.ush"
#include "../BlueNoise.ush"
#include "MegaLights.ush"
#include "MegaLightsRayTracing.ush"
#include "../LightFunctionAtlas/LightFunctionAtlasCommon.usf"

struct FDebug
{
#if DEBUG_MODE
	bool bActive;
	FShaderPrintContext Context;
#endif
};

struct FLightTargetPDF
{
	float3 Diffuse;
	float3 Specular;
	float Weight;
};

FLightTargetPDF InitLightTargetPDF()
{
	FLightTargetPDF LightTargetPDF;
	LightTargetPDF.Diffuse = 0.0f;
	LightTargetPDF.Specular = 0.0f;
	LightTargetPDF.Weight = 0.0f;
	return LightTargetPDF;
}

FLightTargetPDF GetLocalLightTargetPDF(FDeferredLightData LightData, float3 TranslatedWorldPosition, FMegaLightsMaterial Material, uint2 ScreenCoord, inout FDebug Debug)
{
	FLightTargetPDF LightTargetPDF = InitLightTargetPDF();

	float3 CameraVector = normalize(TranslatedWorldPosition - View.TranslatedWorldCameraOrigin);

	float4 LightAttenuation = 1.0f;
	float Dither = 0.5f;
	float SurfaceShadow = 1.0f;
	float AmbientOcclusion = 1.0f;

	LightData.ShadowedBits = 0;

	FDeferredLightingSplit SplitLighting = GetMegaLightsSplitLighting(
		TranslatedWorldPosition, CameraVector, Material, AmbientOcclusion, 
		LightData, LightAttenuation, Dither, ScreenCoord, 
		SurfaceShadow);

	LightTargetPDF.Diffuse = SplitLighting.DiffuseLighting.xyz * View.PreExposure;
	LightTargetPDF.Specular = SplitLighting.SpecularLighting.xyz * View.PreExposure;

	// #ml_todo: move light profile to GetDynamicLightingSplit for better handling
	if (LightData.IESAtlasIndex >= 0 && Luminance(LightTargetPDF.Diffuse + LightTargetPDF.Specular) > 0.01f)
	{
		const float LightProfileMult = ComputeLightProfileMultiplier(TranslatedWorldPosition, LightData.TranslatedWorldPosition, -LightData.Direction, LightData.Tangent, LightData.IESAtlasIndex);
		LightTargetPDF.Diffuse *= LightProfileMult;
		LightTargetPDF.Specular *= LightProfileMult;
	}

	// Simulate tonemapping
	LightTargetPDF.Weight = log2(Luminance(LightTargetPDF.Diffuse + LightTargetPDF.Specular) + 1.0f);

	return LightTargetPDF;
}

uint2 DownsampledViewMin;
uint2 DownsampledViewSize;
float SamplingMinWeight;
uint2 NumSamplesPerPixel;
int DebugMode;

RWTexture2D<float> RWDownsampledSceneDepth;
RWTexture2D<UNORM float3> RWDownsampledSceneWorldNormal;
RWTexture2D<uint> RWLightSamples;

float4 HistoryScreenPositionScaleBias;
float4 HistoryUVMinMax;

groupshared uint SharedCandidateLightHiMask;
groupshared uint SharedCandidateLightMask[SHARED_LIGHT_MASK_SIZE];

StructuredBuffer<uint> DownsampledTileAllocator;
StructuredBuffer<uint> DownsampledTileData;
uint DownsampledTileDataStride;
float2 DownsampledBufferInvSize;

/**
 * Run one thread per sample and generate new light samples for tracing
 */
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void GenerateLightSamplesCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint LinearThreadIndex = GroupThreadId.y * THREADGROUP_SIZE + GroupThreadId.x;

	if (LinearThreadIndex == 0)
	{
		SharedCandidateLightHiMask = 0;
	}

	if (LinearThreadIndex < SHARED_LIGHT_MASK_SIZE)
	{
		SharedCandidateLightMask[LinearThreadIndex] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	uint DownsampledTileIndex = GroupId.x;
	if (DownsampledTileIndex < DownsampledTileAllocator[TILE_TYPE])
	{
		uint LocalCandidateLightHiMask = 0;
		uint2 DownsampledTileCoord = UnpackTile(DownsampledTileData[DownsampledTileIndex + TILE_TYPE * DownsampledTileDataStride]);
		uint2 DownsampledScreenCoord = DownsampledTileCoord * TILE_SIZE + GroupThreadId.xy;

		if (all(DownsampledScreenCoord < DownsampledViewMin + DownsampledViewSize))
		{
			uint2 ScreenCoord = DownsampledScreenCoordToScreenCoord(DownsampledScreenCoord);	
			const float2 ScreenUV = (ScreenCoord + 0.5f) * View.BufferSizeAndInvSize.zw;
			const FMegaLightsMaterial Material = LoadMaterial(ScreenUV, ScreenCoord, TILE_TYPE == TILE_MODE_SIMPLE_SHADING/*bForceSimpleShading*/);
			const float SceneDepth = Material.Depth;

			float3 TranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(ScreenUV, SceneDepth);		

			const uint EyeIndex = 0;
			const uint GridIndex = ComputeLightGridCellIndex(ScreenCoord, SceneDepth, EyeIndex);
			const FCulledLightsGridData CulledLightGridData = GetCulledLightsGrid(GridIndex, EyeIndex);
			const uint NumLightsInGridCell = min(CulledLightGridData.NumLights, GetMaxLightsPerCell(EyeIndex));

			for (uint GridLightIndex = 0; GridLightIndex < NumLightsInGridCell; ++GridLightIndex)
			{
				const uint LocalLightIndex = GetCulledLightDataGrid(CulledLightGridData.DataStartIndex + GridLightIndex);
				const FLocalLightData LocalLightData = GetLocalLightDataNonStereo(LocalLightIndex);

				if (LocalLightData.bMegaLightsSupported && LocalLightIndex < MAX_LOCAL_LIGHT_INDEX)
				{
					uint DWORDIndex = LocalLightIndex / 32;
					uint BitMask = 1u << (LocalLightIndex % 32);
					InterlockedOr(SharedCandidateLightMask[DWORDIndex], BitMask);

					uint HiBitMask = 1u << DWORDIndex;
					LocalCandidateLightHiMask |= HiBitMask;
				}
			}
		}

		uint WaveHiMask = WaveActiveBitOr(LocalCandidateLightHiMask);
		if (WaveIsFirstLane())
		{
			InterlockedOr(SharedCandidateLightHiMask, WaveHiMask);
		}
	
		GroupMemoryBarrierWithGroupSync();

		if (all(DownsampledScreenCoord < DownsampledViewMin + DownsampledViewSize))
		{
			uint2 ScreenCoord = DownsampledScreenCoordToScreenCoord(DownsampledScreenCoord);

			FDebug Debug;
			#if DEBUG_MODE
			{
				int2 DebugScreenCoord = View.CursorPosition.x >= 0 ? View.CursorPosition * View.ViewResolutionFraction : -1;
				Debug.bActive = all(DownsampledScreenCoord == DebugScreenCoord / DOWNSAMPLE_FACTOR);
				Debug.Context = InitShaderPrintContext(true, float2(0.05, 0.05));
			}
			#endif

			FLightSample LightSamples[NUM_SAMPLES_PER_PIXEL_1D];
			for (uint LightSampleIndex = 0; LightSampleIndex < NUM_SAMPLES_PER_PIXEL_1D; ++LightSampleIndex)
			{
				LightSamples[LightSampleIndex] = InitLightSample();
			}

			const float2 ScreenUV = (ScreenCoord + 0.5f) * View.BufferSizeAndInvSize.zw;
			const FMegaLightsMaterial Material = LoadMaterial(ScreenUV, ScreenCoord, TILE_TYPE == TILE_MODE_SIMPLE_SHADING/*bForceSimpleShading*/);
			const float SceneDepth = Material.Depth;
			float WeightSum = 0.0f;

			if (SceneDepth > 0)
			{
				float3 TranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(ScreenUV, SceneDepth);		

				const uint EyeIndex = 0;
				const uint GridIndex = ComputeLightGridCellIndex(ScreenCoord, SceneDepth, EyeIndex);
				const FCulledLightsGridData CulledLightGridData = GetCulledLightsGrid(GridIndex, EyeIndex);
				const uint NumLightsInGridCell = min(CulledLightGridData.NumLights, GetMaxLightsPerCell(EyeIndex));
				const uint NumLocalLights = GetNumLocalLights(EyeIndex);

				// Initialize random variables using spatiotemporal Blue Noise
				float LightIndexRandom[NUM_SAMPLES_PER_PIXEL_1D];
				{
					float GoldenRatioConjugate = 0.6180339887f;
					float RandomScalar = BlueNoiseScalar(DownsampledScreenCoord, MegaLightsStateFrameIndex);

					for (uint LightSampleIndex = 0; LightSampleIndex < NUM_SAMPLES_PER_PIXEL_1D; ++LightSampleIndex)
					{
						LightIndexRandom[LightSampleIndex] = frac(RandomScalar + GoldenRatioConjugate * LightSampleIndex);
					}
				}

				#if DEBUG_MODE
				if (Debug.bActive)
				{
					Print(Debug.Context, TEXT("GenerateSamplesCS"));
					Newline(Debug.Context);
					Print(Debug.Context, TEXT("ScreenCoord: "));
					Print(Debug.Context, ScreenCoord.x);
					Print(Debug.Context, ScreenCoord.y);
					Newline(Debug.Context);
					Print(Debug.Context, TEXT("TileType: "));
					Print(Debug.Context, uint(TILE_TYPE));
					Print(Debug.Context, DownsampledTileAllocator[TILE_TYPE]);
					Newline(Debug.Context);
					Print(Debug.Context, TEXT("View.PreExposure: "));
					Print(Debug.Context, View.PreExposure);
					Newline(Debug.Context);
					Print(Debug.Context, TEXT("NumLightsInGridCell: "));
					Print(Debug.Context, NumLightsInGridCell);
					Print(Debug.Context, TEXT("NumLocalLights: "));
					if (NumLocalLights <= MAX_LOCAL_LIGHT_INDEX)
					{
						Print(Debug.Context, NumLocalLights);
					}
					else
					{
						Print(Debug.Context, NumLocalLights, FontRed);
					}
					AddCrossTWS(Debug.Context, TranslatedWorldPosition, 5.0f, float4(1, 1, 0, 1));
					Newline(Debug.Context);
					Print(Debug.Context, TEXT("LightId  | SampleWeight | LFAtlasIndex | IESAtlasIndex"));
				}
				#endif

				uint CandidateLightHiMask = SharedCandidateLightHiMask;
				while (CandidateLightHiMask != 0)
				{
					const uint NextHiBitIndex = firstbitlow(CandidateLightHiMask);
					const uint NextHiBitMask = 1u << NextHiBitIndex;
					CandidateLightHiMask ^= NextHiBitMask;

					const uint MaskIndex = NextHiBitIndex;
					uint CandidateLightMask = SharedCandidateLightMask[MaskIndex];

					while (CandidateLightMask != 0)
					{
						const uint NextBitIndex = firstbitlow(CandidateLightMask);
						const uint NextBitMask = 1u << NextBitIndex;
						CandidateLightMask ^= NextBitMask;

						const uint LocalLightIndex = MaskIndex * 32 + NextBitIndex;
						const FLocalLightData LocalLightData = GetLocalLightDataNonStereo(LocalLightIndex);
						FDeferredLightData LightData = ConvertToDeferredLight(LocalLightData);
					
						FLightTargetPDF LightTargetPDF = GetLocalLightTargetPDF(LightData, TranslatedWorldPosition, Material, ScreenCoord, Debug);

						#if DEBUG_MODE
						if (Debug.bActive)
						{
							Newline(Debug.Context);
							Print(Debug.Context, LocalLightData.LightSceneId);
							Print(Debug.Context, LightTargetPDF.Weight);
							Print(Debug.Context, LightData.LightFunctionAtlasLightIndex);
							Print(Debug.Context, LightData.IESAtlasIndex);
						}
						#endif

						if (LightTargetPDF.Weight > SamplingMinWeight)
						{
							float Tau = WeightSum / (WeightSum + LightTargetPDF.Weight);
							WeightSum += LightTargetPDF.Weight;

							for (uint LightSampleIndex = 0; LightSampleIndex < NUM_SAMPLES_PER_PIXEL_1D; ++LightSampleIndex)
							{
								if (LightIndexRandom[LightSampleIndex] < Tau)
								{
									LightIndexRandom[LightSampleIndex] /= Tau;
								}
								else
								{
									// Select this sample
									LightIndexRandom[LightSampleIndex] = (LightIndexRandom[LightSampleIndex] - Tau) / (1.0f - Tau);
									LightSamples[LightSampleIndex].LocalLightIndex = LocalLightIndex;
									LightSamples[LightSampleIndex].Weight = LightTargetPDF.Weight;
								}

								LightIndexRandom[LightSampleIndex] = clamp(LightIndexRandom[LightSampleIndex], 0, 0.9999f);
							}
						}
					}
				}

				#if DEBUG_MODE
				if (Debug.bActive)
				{
					Newline(Debug.Context);
					Print(Debug.Context, TEXT("Weight sum: "));
					Print(Debug.Context, WeightSum);
					Newline(Debug.Context);
					Print(Debug.Context, TEXT("Selected lights: "));

					for (uint LightSampleIndex = 0; LightSampleIndex < NUM_SAMPLES_PER_PIXEL_1D; ++LightSampleIndex)
					{
						FLightSample LightSample = LightSamples[LightSampleIndex];
						
						Newline(Debug.Context);
						Print(Debug.Context, LightSample.LocalLightIndex); 
						Print(Debug.Context, LightSample.Weight);
						Print(Debug.Context, WeightSum /  LightSample.Weight);

						if (DebugMode == DEBUG_MODE_VISUALIZE_SAMPLING)
						{
							const uint2 SampleCoord = DownsampledScreenCoord * NumSamplesPerPixel + uint2(LightSampleIndex % NUM_SAMPLES_PER_PIXEL_2D_X, LightSampleIndex / NUM_SAMPLES_PER_PIXEL_2D_X);

							const FLocalLightData LocalLightData = GetLocalLightDataNonStereo(LightSample.LocalLightIndex);
							const FLightSampleTrace LightSampleTrace = GetLightSampleTrace(TranslatedWorldPosition, LightSample.LocalLightIndex, SampleCoord);

							AddLineTWS(Debug.Context, TranslatedWorldPosition, TranslatedWorldPosition + LightSampleTrace.Direction * LightSampleTrace.Distance, float4(LocalLightData.LightColorAndIdAndFalloffExponent.xyz / Luminance(LocalLightData.LightColorAndIdAndFalloffExponent.xyz), 1.0f));
						}
					}
				}
				#endif
			}

			RWDownsampledSceneDepth[DownsampledScreenCoord] = SceneDepth;
			RWDownsampledSceneWorldNormal[DownsampledScreenCoord] = EncodeNormal(Material.WorldNormalForPositionBias);

			for (uint LightSampleIndex = 0; LightSampleIndex < NUM_SAMPLES_PER_PIXEL_1D; ++LightSampleIndex)
			{
				FLightSample LightSample = LightSamples[LightSampleIndex];

				if (LightSample.LocalLightIndex != MAX_LOCAL_LIGHT_INDEX)
				{
					const FLocalLightData LocalLightData = GetLocalLightDataNonStereo(LightSample.LocalLightIndex);
					const bool bCastShadows = UnpackCastShadow(asuint(LocalLightData.LightDirectionAndShadowMask.w));

					LightSample.bVisible = true;
					LightSample.bCompleted = bCastShadows ? false : true;
					LightSample.Weight = WeightSum / (NUM_SAMPLES_PER_PIXEL_1D * LightSample.Weight);
				}

				RWLightSamples[DownsampledScreenCoord * NumSamplesPerPixel + uint2(LightSampleIndex % NUM_SAMPLES_PER_PIXEL_2D_X, LightSampleIndex / NUM_SAMPLES_PER_PIXEL_2D_X)] = PackLightSample(LightSample);
			}
		}
	}
}

/**
 * Clear some data for empty tiles, which won't be processed by GenerateLightSamplesCS
 */
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ClearLightSamplesCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint DownsampledTileIndex = GroupId.x;
	if (DownsampledTileIndex < DownsampledTileAllocator[TILE_MODE_EMPTY])
	{
		uint2 DownsampledTileCoord = UnpackTile(DownsampledTileData[DownsampledTileIndex + TILE_MODE_EMPTY * DownsampledTileDataStride]);
		uint2 DownsampledScreenCoord = DownsampledTileCoord * TILE_SIZE + GroupThreadId.xy;

		if (all(DownsampledScreenCoord < DownsampledViewMin + DownsampledViewSize))
		{
			for (uint LightSampleY = 0; LightSampleY < NumSamplesPerPixel.y; ++LightSampleY)
			{
				for (uint LightSampleX = 0; LightSampleX < NumSamplesPerPixel.x; ++LightSampleX)
				{
					FLightSample LightSample = InitLightSample();
					RWLightSamples[DownsampledScreenCoord * NumSamplesPerPixel + uint2(LightSampleX, LightSampleY)] = PackLightSample(LightSample);
				}
			}
		}
	}
}