// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "../SplineMeshCommon.ush"
#include "NaniteDataDecode.ush"
#include "NaniteAttributeDecode.ush"

// Represents vertex data for a Nanite mesh in local space
struct FNaniteLocalVertex
{
	// Index of the vertex in the cluster
	uint VertIndex;
	// Decoded vertex position
	float3 Position;
	// Decoded vertex attribute data
	FNaniteRawAttributeData RawAttributeData;
};

// Decodes vertex data for the specified vertex in a cluster (and potentially deforms it into final local space)
FNaniteLocalVertex FetchLocalNaniteVertex(FCluster Cluster, uint VertIndex, uint CompileTimeMaxTexCoords)
{
	FNaniteLocalVertex Output = (FNaniteLocalVertex)0;

	Output.VertIndex = VertIndex;
	Output.Position = DecodePosition(VertIndex, Cluster);
	Output.RawAttributeData = GetRawAttributeData(Cluster, VertIndex, CompileTimeMaxTexCoords);

	return Output;
}

void FetchLocalNaniteTriangle(FCluster Cluster, uint3 VertIndexes, uint CompileTimeMaxTexCoords, inout FNaniteLocalVertex OutVerts[3])
{
	const float3 Positions[3] = 
	{
		DecodePosition(VertIndexes.x, Cluster),
		DecodePosition(VertIndexes.y, Cluster),
		DecodePosition(VertIndexes.z, Cluster)
	};

	FNaniteRawAttributeData RawAttributeData[3];
	GetRawAttributeData3(RawAttributeData, Cluster, VertIndexes, CompileTimeMaxTexCoords);

	UNROLL_N(3)
	for (uint i = 0; i < 3; ++i)
	{
		OutVerts[i].VertIndex			= VertIndexes[i];
		OutVerts[i].Position			= Positions[i];
		OutVerts[i].RawAttributeData	= RawAttributeData[i];
	}
}


// Represents vertex data for a Nanite mesh in local space, post-deformation (when applicable)
struct FNanitePostDeformVertex
{
	// Index of the vertex in the cluster
	uint VertIndex;

	// Post-deformed position of the vertex
	float3 Position;

	// Decoded vertex position (BEFORE deformation)
	float3 PointLocal;

	// Vertex normal (BEFORE deformation)
	float3 PreSkinnedNormal;

	// Post-deformed tangent basis of the vertex
	FNaniteTangentBasis TangentBasis;

	// Normalized distance along the spline (spline meshes only)
	half SplineDist;

	// Decoded vertex attribute data
	FNaniteRawAttributeData RawAttributeData;
};

FNanitePostDeformVertex DeformLocalNaniteVertex(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FCluster Cluster, FNaniteLocalVertex Input)
{
	FNanitePostDeformVertex Output;
	Output.VertIndex			= Input.VertIndex;
	Output.TangentBasis			= MakeTangentBasis(Input.RawAttributeData);
	Output.SplineDist			= 0.0f;
	Output.RawAttributeData		= Input.RawAttributeData;
	Output.PointLocal			= Input.Position;
	Output.Position				= Input.Position;
	Output.PreSkinnedNormal		= Output.TangentBasis.TangentZ;

#if USE_SKINNING
	BRANCH
	if ((PrimitiveData.Flags & PRIMITIVE_SCENE_DATA_FLAG_SKINNED_MESH) != 0 && Cluster.bSkinning)
	{
		FNaniteSkinningHeader SkinningHeader = LoadNaniteSkinningHeader(InstanceData.PrimitiveId);
		FBoneInfluenceHeader BoneInfluenceHeader = GetBoneInfluenceHeader(Cluster);

		float3 SkinnedPosition = float3(0.0f, 0.0f, 0.0f);
		float3 SkinnedNormal = float3(0.0f, 0.0f, 0.0f);
		float3 SkinnedTangent = float3(0.0f, 0.0f, 0.0f);

		LOOP
		for (uint InfluenceIndex = 0; InfluenceIndex < BoneInfluenceHeader.NumVertexBoneInfluences; ++InfluenceIndex)
		{
			uint BoneIndex = 0;
			float BoneWeight = 0.0f;
			DecodeVertexBoneInfluence(BoneInfluenceHeader, Input.VertIndex, InfluenceIndex, BoneIndex, BoneWeight);

			const float3x4 BoneTransform = LoadNaniteBoneTransform(SkinningHeader.TransformBufferOffset + InstanceData.SkinningData + BoneIndex);
			SkinnedPosition	+= mul(BoneTransform, float4(Input.Position, 1.0f)) * BoneWeight;
			SkinnedNormal	+= mul((float3x3)BoneTransform, Output.TangentBasis.TangentZ) * BoneWeight;
			SkinnedTangent	+= mul((float3x3)BoneTransform, Output.TangentBasis.TangentXAndSign.xyz) * BoneWeight;
		}

		Output.TangentBasis.TangentZ = SkinnedNormal;
		Output.TangentBasis.TangentXAndSign.xyz = SkinnedTangent;

	#if 0
		Output.TangentBasis.RecalculateTangentX();
	#endif

		Output.Position = SkinnedPosition;
	}
#endif

#if USE_SPLINEDEFORM
	BRANCH
	if ((PrimitiveData.Flags & PRIMITIVE_SCENE_DATA_FLAG_SPLINE_MESH) != 0 &&
		(InstanceData.Flags & INSTANCE_SCENE_DATA_FLAG_HAS_PAYLOAD_EXTENSION) != 0)
	{
		// Deform the local position and tangent basis along the spline
		// NOTE: Storing off the spline distance for use later when calculating tangent frame.
		FSplineMeshShaderParams SplineMeshParams = SplineMeshLoadParamsFromInstancePayload(InstanceData);
		Output.SplineDist = SplineMeshDeformLocalPosNormalTangent(
			SplineMeshParams,
			Output.Position,
			Output.TangentBasis.TangentZ,
			Output.TangentBasis.TangentXAndSign.xyz
		);
	}
#endif

	return Output;
}

FNanitePostDeformVertex FetchAndDeformLocalNaniteVertex(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FCluster Cluster, uint VertIndex, uint CompileTimeMaxTexCoords)
{
	return DeformLocalNaniteVertex(PrimitiveData, InstanceData, Cluster, FetchLocalNaniteVertex(Cluster, VertIndex, CompileTimeMaxTexCoords));
}

void FetchAndDeformLocalNaniteTriangle(FPrimitiveSceneData PrimitiveData, FInstanceSceneData InstanceData, FCluster Cluster, uint3 VertIndexes, uint CompileTimeMaxTexCoords, inout FNanitePostDeformVertex OutVerts[3])
{
	FNaniteLocalVertex InVerts[3];
	FetchLocalNaniteTriangle(Cluster, VertIndexes, CompileTimeMaxTexCoords, InVerts);

	UNROLL_N(3)
	for(uint i = 0; i < 3; ++i)
	{
		OutVerts[i] = DeformLocalNaniteVertex(PrimitiveData, InstanceData, Cluster, InVerts[i]);
	}
}
